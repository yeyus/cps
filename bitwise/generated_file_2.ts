/* eslint-disable max-classes-per-file */
/* This file is AUTO-GENERATED by the bitwise to TS compiler so scram! */
import BitView from "../bitview";

export class MemoryMapMemory {
  public static BASE: number = 8;

  public static LENGTH: number = 2048;

  public rxfreq: number[];

  public txfreq: number[];

  public rxtone: number;

  public txtone: number;

  public unused1: number;

  public isuhf: boolean;

  public scode: number;

  public unknown1: number;

  public txtoneicon: boolean;

  public mailicon: number;

  public unknown2: number;

  public lowpower: number;

  public unknown3: boolean;

  public wide: boolean;

  public unknown4: number;

  public bcl: boolean;

  public scan: boolean;

  public pttid: number;

  public static fromBuffer(buffer: Uint8Array, offset: number): MemoryMapMemory {
    const dataView = new DataView(buffer.buffer);
    const memory = new MemoryMapMemory();
    let currentOffset = offset ?? MemoryMapMemory.BASE;
    for (let i = 0; i < 4; i += 1) {
      memory.rxfreq.push(parseInt(buffer.at(currentOffset + i * 1).toString(16), 10));
    }
    currentOffset += 4;
    for (let i = 0; i < 4; i += 1) {
      memory.txfreq.push(parseInt(buffer.at(currentOffset + i * 1).toString(16), 10));
    }
    currentOffset += 4;
    memory.rxtone = dataView.getUint16(currentOffset, true);
    currentOffset += 2;
    memory.txtone = dataView.getUint16(currentOffset, true);
    currentOffset += 2;
    memory.unused1 = BitView.asNumber(buffer, currentOffset, 5, 3);
    memory.isuhf = BitView.asBoolean(buffer, currentOffset, 4);
    memory.scode = BitView.asNumber(buffer, currentOffset, 0, 4);
    currentOffset += 1;
    memory.unknown1 = BitView.asNumber(buffer, currentOffset, 1, 7);
    memory.txtoneicon = BitView.asBoolean(buffer, currentOffset, 0);
    currentOffset += 1;
    memory.mailicon = BitView.asNumber(buffer, currentOffset, 5, 3);
    memory.unknown2 = BitView.asNumber(buffer, currentOffset, 2, 3);
    memory.lowpower = BitView.asNumber(buffer, currentOffset, 0, 2);
    currentOffset += 1;
    memory.unknown3 = BitView.asBoolean(buffer, currentOffset, 7);
    memory.wide = BitView.asBoolean(buffer, currentOffset, 6);
    memory.unknown4 = BitView.asNumber(buffer, currentOffset, 4, 2);
    memory.bcl = BitView.asBoolean(buffer, currentOffset, 3);
    memory.scan = BitView.asBoolean(buffer, currentOffset, 2);
    memory.pttid = BitView.asNumber(buffer, currentOffset, 0, 2);
    currentOffset += 1;
    return memory;
  }
}
export class MemoryMapPttid {
  public static BASE: number = 2824;

  public static LENGTH: number = 240;

  public code: number[];

  public unused: number[];

  public static fromBuffer(buffer: Uint8Array, offset: number): MemoryMapPttid {
    const dataView = new DataView(buffer.buffer);
    const pttid = new MemoryMapPttid();
    let currentOffset = offset ?? MemoryMapPttid.BASE;
    for (let i = 0; i < 5; i += 1) {
      pttid.code.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 5;
    for (let i = 0; i < 11; i += 1) {
      pttid.unused.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 11;
    return pttid;
  }
}
export class MemoryMapAni {
  public static BASE: number = 3208;

  public static LENGTH: number = 52;

  public code222: number[];

  public unused222: number[];

  public code333: number[];

  public unused333: number[];

  public alarmcode: number[];

  public unused119: number[];

  public unknown1: number;

  public code555: number[];

  public unused555: number[];

  public code666: number[];

  public unused666: number[];

  public code777: number[];

  public unused777: number[];

  public unknown2: number;

  public code60606: number[];

  public code70707: number[];

  public code: number[];

  public unused1: number;

  public aniid: number;

  public unknown: number[];

  public dtmfon: number;

  public dtmfoff: number;

  public static fromBuffer(buffer: Uint8Array, offset: number): MemoryMapAni {
    const dataView = new DataView(buffer.buffer);
    const ani = new MemoryMapAni();
    let currentOffset = offset ?? MemoryMapAni.BASE;
    for (let i = 0; i < 3; i += 1) {
      ani.code222.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 3;
    for (let i = 0; i < 2; i += 1) {
      ani.unused222.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 2;
    for (let i = 0; i < 3; i += 1) {
      ani.code333.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 3;
    for (let i = 0; i < 2; i += 1) {
      ani.unused333.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 2;
    for (let i = 0; i < 3; i += 1) {
      ani.alarmcode.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 3;
    for (let i = 0; i < 2; i += 1) {
      ani.unused119.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 2;
    ani.unknown1 = dataView.getUint8(currentOffset);
    currentOffset += 1;
    for (let i = 0; i < 3; i += 1) {
      ani.code555.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 3;
    for (let i = 0; i < 2; i += 1) {
      ani.unused555.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 2;
    for (let i = 0; i < 3; i += 1) {
      ani.code666.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 3;
    for (let i = 0; i < 2; i += 1) {
      ani.unused666.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 2;
    for (let i = 0; i < 3; i += 1) {
      ani.code777.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 3;
    for (let i = 0; i < 2; i += 1) {
      ani.unused777.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 2;
    ani.unknown2 = dataView.getUint8(currentOffset);
    currentOffset += 1;
    for (let i = 0; i < 5; i += 1) {
      ani.code60606.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 5;
    for (let i = 0; i < 5; i += 1) {
      ani.code70707.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 5;
    for (let i = 0; i < 5; i += 1) {
      ani.code.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 5;
    ani.unused1 = BitView.asNumber(buffer, currentOffset, 2, 6);
    ani.aniid = BitView.asNumber(buffer, currentOffset, 0, 2);
    currentOffset += 1;
    for (let i = 0; i < 2; i += 1) {
      ani.unknown.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 2;
    ani.dtmfon = dataView.getUint8(currentOffset);
    currentOffset += 1;
    ani.dtmfoff = dataView.getUint8(currentOffset);
    currentOffset += 1;
    return ani;
  }
}
export class MemoryMapSettings {
  public static BASE: number = 3624;

  public static LENGTH: number = 46;

  public squelch: number;

  public step: number;

  public unknown1: number;

  public save: number;

  public vox: number;

  public unknown2: number;

  public abr: number;

  public tdr: number;

  public beep: number;

  public timeout: number;

  public unknown3: number[];

  public voice: number;

  public unknown4: number;

  public dtmfst: number;

  public unknown5: number;

  public unknown12: number;

  public screv: number;

  public pttid: number;

  public pttlt: number;

  public mdfa: number;

  public mdfb: number;

  public bcl: number;

  public autolk: number;

  public sftd: number;

  public unknown6: number[];

  public wtled: number;

  public rxled: number;

  public txled: number;

  public almod: number;

  public band: number;

  public tdrab: number;

  public ste: number;

  public rpste: number;

  public rptrl: number;

  public ponmsg: number;

  public roger: number;

  public rogerrx: number;

  public tdrch: number;

  public displayab: boolean;

  public unknown7: number;

  public fmradio: boolean;

  public alarm: boolean;

  public unknown8: boolean;

  public reset: boolean;

  public menu: boolean;

  public unknown9: number;

  public singleptt: boolean;

  public vfomrlock: boolean;

  public workmode: number;

  public keylock: number;

  public static fromBuffer(buffer: Uint8Array, offset: number): MemoryMapSettings {
    const dataView = new DataView(buffer.buffer);
    const settings = new MemoryMapSettings();
    let currentOffset = offset ?? MemoryMapSettings.BASE;
    settings.squelch = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.step = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.unknown1 = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.save = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.vox = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.unknown2 = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.abr = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.tdr = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.beep = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.timeout = dataView.getUint8(currentOffset);
    currentOffset += 1;
    for (let i = 0; i < 4; i += 1) {
      settings.unknown3.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 4;
    settings.voice = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.unknown4 = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.dtmfst = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.unknown5 = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.unknown12 = BitView.asNumber(buffer, currentOffset, 2, 6);
    settings.screv = BitView.asNumber(buffer, currentOffset, 0, 2);
    currentOffset += 1;
    settings.pttid = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.pttlt = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.mdfa = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.mdfb = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.bcl = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.autolk = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.sftd = dataView.getUint8(currentOffset);
    currentOffset += 1;
    for (let i = 0; i < 3; i += 1) {
      settings.unknown6.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 3;
    settings.wtled = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.rxled = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.txled = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.almod = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.band = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.tdrab = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.ste = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.rpste = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.rptrl = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.ponmsg = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.roger = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.rogerrx = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.tdrch = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.displayab = BitView.asBoolean(buffer, currentOffset, 7);
    settings.unknown7 = BitView.asNumber(buffer, currentOffset, 5, 2);
    settings.fmradio = BitView.asBoolean(buffer, currentOffset, 4);
    settings.alarm = BitView.asBoolean(buffer, currentOffset, 3);
    settings.unknown8 = BitView.asBoolean(buffer, currentOffset, 2);
    settings.reset = BitView.asBoolean(buffer, currentOffset, 1);
    settings.menu = BitView.asBoolean(buffer, currentOffset, 0);
    currentOffset += 1;
    settings.unknown9 = BitView.asNumber(buffer, currentOffset, 2, 6);
    settings.singleptt = BitView.asBoolean(buffer, currentOffset, 1);
    settings.vfomrlock = BitView.asBoolean(buffer, currentOffset, 0);
    currentOffset += 1;
    settings.workmode = dataView.getUint8(currentOffset);
    currentOffset += 1;
    settings.keylock = dataView.getUint8(currentOffset);
    currentOffset += 1;
    return settings;
  }
}
export class MemoryMapWmchannel {
  public static BASE: number = 3710;

  public static LENGTH: number = 2;

  public unused1: boolean;

  public mrcha: number;

  public unused2: boolean;

  public mrchb: number;

  public static fromBuffer(buffer: Uint8Array, offset: number): MemoryMapWmchannel {
    const dataView = new DataView(buffer.buffer);
    const wmchannel = new MemoryMapWmchannel();
    let currentOffset = offset ?? MemoryMapWmchannel.BASE;
    wmchannel.unused1 = BitView.asBoolean(buffer, currentOffset, 7);
    wmchannel.mrcha = BitView.asNumber(buffer, currentOffset, 0, 7);
    currentOffset += 1;
    wmchannel.unused2 = BitView.asBoolean(buffer, currentOffset, 7);
    wmchannel.mrchb = BitView.asNumber(buffer, currentOffset, 0, 7);
    currentOffset += 1;
    return wmchannel;
  }
}
export class MemoryMapVfoa {
  public static BASE: number = 3856;

  public static LENGTH: number = 24;

  public freq: number[];

  public offset: number[];

  public rxtone: number;

  public txtone: number;

  public unused1: number;

  public band: boolean;

  public unknown3: number;

  public unused2: number;

  public sftd: number;

  public scode: number;

  public unknown4: number;

  public unused3: boolean;

  public step: number;

  public unused4: number;

  public txpower: boolean;

  public widenarr: boolean;

  public unknown5: number;

  public txpower3: number;

  public static fromBuffer(buffer: Uint8Array, offset: number): MemoryMapVfoa {
    const dataView = new DataView(buffer.buffer);
    const vfoa = new MemoryMapVfoa();
    let currentOffset = offset ?? MemoryMapVfoa.BASE;
    for (let i = 0; i < 8; i += 1) {
      vfoa.freq.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 8;
    for (let i = 0; i < 6; i += 1) {
      vfoa.offset.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 6;
    vfoa.rxtone = dataView.getUint16(currentOffset, true);
    currentOffset += 2;
    vfoa.txtone = dataView.getUint16(currentOffset, true);
    currentOffset += 2;
    vfoa.unused1 = BitView.asNumber(buffer, currentOffset, 1, 7);
    vfoa.band = BitView.asBoolean(buffer, currentOffset, 0);
    currentOffset += 1;
    vfoa.unknown3 = dataView.getUint8(currentOffset);
    currentOffset += 1;
    vfoa.unused2 = BitView.asNumber(buffer, currentOffset, 6, 2);
    vfoa.sftd = BitView.asNumber(buffer, currentOffset, 4, 2);
    vfoa.scode = BitView.asNumber(buffer, currentOffset, 0, 4);
    currentOffset += 1;
    vfoa.unknown4 = dataView.getUint8(currentOffset);
    currentOffset += 1;
    vfoa.unused3 = BitView.asBoolean(buffer, currentOffset, 7);
    vfoa.step = BitView.asNumber(buffer, currentOffset, 4, 3);
    vfoa.unused4 = BitView.asNumber(buffer, currentOffset, 0, 4);
    currentOffset += 1;
    vfoa.txpower = BitView.asBoolean(buffer, currentOffset, 7);
    vfoa.widenarr = BitView.asBoolean(buffer, currentOffset, 6);
    vfoa.unknown5 = BitView.asNumber(buffer, currentOffset, 2, 4);
    vfoa.txpower3 = BitView.asNumber(buffer, currentOffset, 0, 2);
    currentOffset += 1;
    return vfoa;
  }
}
export class MemoryMapVfob {
  public static BASE: number = 3888;

  public static LENGTH: number = 24;

  public freq: number[];

  public offset: number[];

  public rxtone: number;

  public txtone: number;

  public unused1: number;

  public band: boolean;

  public unknown3: number;

  public unused2: number;

  public sftd: number;

  public scode: number;

  public unknown4: number;

  public unused3: boolean;

  public step: number;

  public unused4: number;

  public txpower: boolean;

  public widenarr: boolean;

  public unknown5: number;

  public txpower3: number;

  public static fromBuffer(buffer: Uint8Array, offset: number): MemoryMapVfob {
    const dataView = new DataView(buffer.buffer);
    const vfob = new MemoryMapVfob();
    let currentOffset = offset ?? MemoryMapVfob.BASE;
    for (let i = 0; i < 8; i += 1) {
      vfob.freq.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 8;
    for (let i = 0; i < 6; i += 1) {
      vfob.offset.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 6;
    vfob.rxtone = dataView.getUint16(currentOffset, true);
    currentOffset += 2;
    vfob.txtone = dataView.getUint16(currentOffset, true);
    currentOffset += 2;
    vfob.unused1 = BitView.asNumber(buffer, currentOffset, 1, 7);
    vfob.band = BitView.asBoolean(buffer, currentOffset, 0);
    currentOffset += 1;
    vfob.unknown3 = dataView.getUint8(currentOffset);
    currentOffset += 1;
    vfob.unused2 = BitView.asNumber(buffer, currentOffset, 6, 2);
    vfob.sftd = BitView.asNumber(buffer, currentOffset, 4, 2);
    vfob.scode = BitView.asNumber(buffer, currentOffset, 0, 4);
    currentOffset += 1;
    vfob.unknown4 = dataView.getUint8(currentOffset);
    currentOffset += 1;
    vfob.unused3 = BitView.asBoolean(buffer, currentOffset, 7);
    vfob.step = BitView.asNumber(buffer, currentOffset, 4, 3);
    vfob.unused4 = BitView.asNumber(buffer, currentOffset, 0, 4);
    currentOffset += 1;
    vfob.txpower = BitView.asBoolean(buffer, currentOffset, 7);
    vfob.widenarr = BitView.asBoolean(buffer, currentOffset, 6);
    vfob.unknown5 = BitView.asNumber(buffer, currentOffset, 2, 4);
    vfob.txpower3 = BitView.asNumber(buffer, currentOffset, 0, 2);
    currentOffset += 1;
    return vfob;
  }
}
export class MemoryMapNames {
  public static BASE: number = 4104;

  public static LENGTH: number = 2048;

  public name: string[];

  public unknown2: number[];

  public static fromBuffer(buffer: Uint8Array, offset: number): MemoryMapNames {
    const dataView = new DataView(buffer.buffer);
    const names = new MemoryMapNames();
    let currentOffset = offset ?? MemoryMapNames.BASE;
    for (let i = 0; i < 7; i += 1) {
      names.name.push(String.fromCharCode(buffer.at(currentOffset + i * 1)));
    }
    currentOffset += 7;
    for (let i = 0; i < 9; i += 1) {
      names.unknown2.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 9;
    return names;
  }
}
export class MemoryMapSixpoweronMsg {
  public static BASE: number = 6168;

  public static LENGTH: number = 14;

  public line1: string[];

  public line2: string[];

  public static fromBuffer(buffer: Uint8Array, offset: number): MemoryMapSixpoweronMsg {
    const dataView = new DataView(buffer.buffer);
    const sixpoweronMsg = new MemoryMapSixpoweronMsg();
    let currentOffset = offset ?? MemoryMapSixpoweronMsg.BASE;
    for (let i = 0; i < 7; i += 1) {
      sixpoweronMsg.line1.push(String.fromCharCode(buffer.at(currentOffset + i * 1)));
    }
    currentOffset += 7;
    for (let i = 0; i < 7; i += 1) {
      sixpoweronMsg.line2.push(String.fromCharCode(buffer.at(currentOffset + i * 1)));
    }
    currentOffset += 7;
    return sixpoweronMsg;
  }
}
export class MemoryMapPoweronMsg {
  public static BASE: number = 6184;

  public static LENGTH: number = 14;

  public line1: string[];

  public line2: string[];

  public static fromBuffer(buffer: Uint8Array, offset: number): MemoryMapPoweronMsg {
    const dataView = new DataView(buffer.buffer);
    const poweronMsg = new MemoryMapPoweronMsg();
    let currentOffset = offset ?? MemoryMapPoweronMsg.BASE;
    for (let i = 0; i < 7; i += 1) {
      poweronMsg.line1.push(String.fromCharCode(buffer.at(currentOffset + i * 1)));
    }
    currentOffset += 7;
    for (let i = 0; i < 7; i += 1) {
      poweronMsg.line2.push(String.fromCharCode(buffer.at(currentOffset + i * 1)));
    }
    currentOffset += 7;
    return poweronMsg;
  }
}
export class MemoryMapFirmwareMsg {
  public static BASE: number = 6200;

  public static LENGTH: number = 14;

  public line1: string[];

  public line2: string[];

  public static fromBuffer(buffer: Uint8Array, offset: number): MemoryMapFirmwareMsg {
    const dataView = new DataView(buffer.buffer);
    const firmwareMsg = new MemoryMapFirmwareMsg();
    let currentOffset = offset ?? MemoryMapFirmwareMsg.BASE;
    for (let i = 0; i < 7; i += 1) {
      firmwareMsg.line1.push(String.fromCharCode(buffer.at(currentOffset + i * 1)));
    }
    currentOffset += 7;
    for (let i = 0; i < 7; i += 1) {
      firmwareMsg.line2.push(String.fromCharCode(buffer.at(currentOffset + i * 1)));
    }
    currentOffset += 7;
    return firmwareMsg;
  }
}
export class MemoryMapSquelch {
  public static LENGTH: number = 10;

  public sql0: number;

  public sql1: number;

  public sql2: number;

  public sql3: number;

  public sql4: number;

  public sql5: number;

  public sql6: number;

  public sql7: number;

  public sql8: number;

  public sql9: number;

  public static fromBuffer(buffer: Uint8Array, offset: number): MemoryMapSquelch {
    const dataView = new DataView(buffer.buffer);
    const squelch = new MemoryMapSquelch();
    let currentOffset = offset;
    squelch.sql0 = dataView.getUint8(currentOffset);
    currentOffset += 1;
    squelch.sql1 = dataView.getUint8(currentOffset);
    currentOffset += 1;
    squelch.sql2 = dataView.getUint8(currentOffset);
    currentOffset += 1;
    squelch.sql3 = dataView.getUint8(currentOffset);
    currentOffset += 1;
    squelch.sql4 = dataView.getUint8(currentOffset);
    currentOffset += 1;
    squelch.sql5 = dataView.getUint8(currentOffset);
    currentOffset += 1;
    squelch.sql6 = dataView.getUint8(currentOffset);
    currentOffset += 1;
    squelch.sql7 = dataView.getUint8(currentOffset);
    currentOffset += 1;
    squelch.sql8 = dataView.getUint8(currentOffset);
    currentOffset += 1;
    squelch.sql9 = dataView.getUint8(currentOffset);
    currentOffset += 1;
    return squelch;
  }
}
export class MemoryMapSquelchNew {
  public static BASE: number = 6312;

  public static LENGTH: number = 42;

  public vhf: MemoryMapSquelch;

  public unknown1: number[];

  public unknown2: number[];

  public uhf: MemoryMapSquelch;

  public static fromBuffer(buffer: Uint8Array, offset: number): MemoryMapSquelchNew {
    const dataView = new DataView(buffer.buffer);
    const squelchNew = new MemoryMapSquelchNew();
    let currentOffset = offset ?? MemoryMapSquelchNew.BASE;
    squelchNew.vhf = MemoryMapSquelch.fromBuffer(buffer, currentOffset);
    currentOffset += MemoryMapSquelch.LENGTH;
    for (let i = 0; i < 6; i += 1) {
      squelchNew.unknown1.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 6;
    for (let i = 0; i < 16; i += 1) {
      squelchNew.unknown2.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 16;
    squelchNew.uhf = MemoryMapSquelch.fromBuffer(buffer, currentOffset);
    currentOffset += MemoryMapSquelch.LENGTH;
    return squelchNew;
  }
}
export class MemoryMapSquelchOld {
  public static BASE: number = 6376;

  public static LENGTH: number = 26;

  public vhf: MemoryMapSquelch;

  public unknown: number[];

  public uhf: MemoryMapSquelch;

  public static fromBuffer(buffer: Uint8Array, offset: number): MemoryMapSquelchOld {
    const dataView = new DataView(buffer.buffer);
    const squelchOld = new MemoryMapSquelchOld();
    let currentOffset = offset ?? MemoryMapSquelchOld.BASE;
    squelchOld.vhf = MemoryMapSquelch.fromBuffer(buffer, currentOffset);
    currentOffset += MemoryMapSquelch.LENGTH;
    for (let i = 0; i < 6; i += 1) {
      squelchOld.unknown.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 6;
    squelchOld.uhf = MemoryMapSquelch.fromBuffer(buffer, currentOffset);
    currentOffset += MemoryMapSquelch.LENGTH;
    return squelchOld;
  }
}
export class MemoryMapLimit {
  public static LENGTH: number = 5;

  public enable: number;

  public lower: number[];

  public upper: number[];

  public static fromBuffer(buffer: Uint8Array, offset: number): MemoryMapLimit {
    const dataView = new DataView(buffer.buffer);
    const limit = new MemoryMapLimit();
    let currentOffset = offset;
    limit.enable = dataView.getUint8(currentOffset);
    currentOffset += 1;
    for (let i = 0; i < 2; i += 1) {
      limit.lower.push(parseInt(buffer.at(currentOffset + i * 1).toString(16), 10));
    }
    currentOffset += 2;
    for (let i = 0; i < 2; i += 1) {
      limit.upper.push(parseInt(buffer.at(currentOffset + i * 1).toString(16), 10));
    }
    currentOffset += 2;
    return limit;
  }
}
export class MemoryMapLimitsNew {
  public static BASE: number = 6408;

  public static LENGTH: number = 10;

  public vhf: MemoryMapLimit;

  public uhf: MemoryMapLimit;

  public static fromBuffer(buffer: Uint8Array, offset: number): MemoryMapLimitsNew {
    const dataView = new DataView(buffer.buffer);
    const limitsNew = new MemoryMapLimitsNew();
    let currentOffset = offset ?? MemoryMapLimitsNew.BASE;
    limitsNew.vhf = MemoryMapLimit.fromBuffer(buffer, currentOffset);
    currentOffset += MemoryMapLimit.LENGTH;
    limitsNew.uhf = MemoryMapLimit.fromBuffer(buffer, currentOffset);
    currentOffset += MemoryMapLimit.LENGTH;
    return limitsNew;
  }
}
export class MemoryMapLimitsOld {
  public static BASE: number = 6416;

  public static LENGTH: number = 23;

  public unknown1: number[];

  public vhf: MemoryMapLimit;

  public unknown2: number;

  public unknown3: number[];

  public unknown4: number[];

  public uhf: MemoryMapLimit;

  public static fromBuffer(buffer: Uint8Array, offset: number): MemoryMapLimitsOld {
    const dataView = new DataView(buffer.buffer);
    const limitsOld = new MemoryMapLimitsOld();
    let currentOffset = offset ?? MemoryMapLimitsOld.BASE;
    for (let i = 0; i < 2; i += 1) {
      limitsOld.unknown1.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 2;
    limitsOld.vhf = MemoryMapLimit.fromBuffer(buffer, currentOffset);
    currentOffset += MemoryMapLimit.LENGTH;
    limitsOld.unknown2 = dataView.getUint8(currentOffset);
    currentOffset += 1;
    for (let i = 0; i < 8; i += 1) {
      limitsOld.unknown3.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 8;
    for (let i = 0; i < 2; i += 1) {
      limitsOld.unknown4.push(dataView.getUint8(currentOffset + i * 1));
    }
    currentOffset += 2;
    limitsOld.uhf = MemoryMapLimit.fromBuffer(buffer, currentOffset);
    currentOffset += MemoryMapLimit.LENGTH;
    return limitsOld;
  }
}
export class QuanshengUVK5MemoryMap {
  public memory: MemoryMapMemory[];

  public pttid: MemoryMapPttid[];

  public ani: MemoryMapAni;

  public settings: MemoryMapSettings;

  public wmchannel: MemoryMapWmchannel;

  public vfoa: MemoryMapVfoa;

  public vfob: MemoryMapVfob;

  public fmPresets: number;

  public names: MemoryMapNames[];

  public sixpoweronMsg: MemoryMapSixpoweronMsg;

  public poweronMsg: MemoryMapPoweronMsg;

  public firmwareMsg: MemoryMapFirmwareMsg;

  public squelchNew: MemoryMapSquelchNew;

  public squelchOld: MemoryMapSquelchOld;

  public limitsNew: MemoryMapLimitsNew;

  public limitsOld: MemoryMapLimitsOld;

  public static fromBuffer(buffer: Uint8Array): QuanshengUVK5MemoryMap {
    const dataView = new DataView(buffer.buffer);
    const memoryMap = new QuanshengUVK5MemoryMap();
    let currentOffset = 0;
    for (let i = 0; i < 128; i += 1) {
      memoryMap.memory.push(MemoryMapMemory.fromBuffer(buffer, MemoryMapMemory.BASE + i * MemoryMapMemory.LENGTH));
    }
    for (let i = 0; i < 15; i += 1) {
      memoryMap.pttid.push(MemoryMapPttid.fromBuffer(buffer, MemoryMapPttid.BASE + i * MemoryMapPttid.LENGTH));
    }
    currentOffset = 3208;
    memoryMap.ani = MemoryMapAni.fromBuffer(buffer, currentOffset);
    currentOffset += MemoryMapAni.LENGTH;
    currentOffset = 3624;
    memoryMap.settings = MemoryMapSettings.fromBuffer(buffer, currentOffset);
    currentOffset += MemoryMapSettings.LENGTH;
    currentOffset = 3710;
    memoryMap.wmchannel = MemoryMapWmchannel.fromBuffer(buffer, currentOffset);
    currentOffset += MemoryMapWmchannel.LENGTH;
    currentOffset = 3856;
    memoryMap.vfoa = MemoryMapVfoa.fromBuffer(buffer, currentOffset);
    currentOffset += MemoryMapVfoa.LENGTH;
    currentOffset = 3888;
    memoryMap.vfob = MemoryMapVfob.fromBuffer(buffer, currentOffset);
    currentOffset += MemoryMapVfob.LENGTH;
    currentOffset = 3926;
    memoryMap.fmPresets = dataView.getUint16(currentOffset);
    currentOffset += 2;
    for (let i = 0; i < 128; i += 1) {
      memoryMap.names.push(MemoryMapNames.fromBuffer(buffer, MemoryMapNames.BASE + i * MemoryMapNames.LENGTH));
    }
    currentOffset = 6168;
    memoryMap.sixpoweronMsg = MemoryMapSixpoweronMsg.fromBuffer(buffer, currentOffset);
    currentOffset += MemoryMapSixpoweronMsg.LENGTH;
    currentOffset = 6184;
    memoryMap.poweronMsg = MemoryMapPoweronMsg.fromBuffer(buffer, currentOffset);
    currentOffset += MemoryMapPoweronMsg.LENGTH;
    currentOffset = 6200;
    memoryMap.firmwareMsg = MemoryMapFirmwareMsg.fromBuffer(buffer, currentOffset);
    currentOffset += MemoryMapFirmwareMsg.LENGTH;
    currentOffset = 6312;
    memoryMap.squelchNew = MemoryMapSquelchNew.fromBuffer(buffer, currentOffset);
    currentOffset += MemoryMapSquelchNew.LENGTH;
    currentOffset = 6376;
    memoryMap.squelchOld = MemoryMapSquelchOld.fromBuffer(buffer, currentOffset);
    currentOffset += MemoryMapSquelchOld.LENGTH;
    currentOffset = 6408;
    memoryMap.limitsNew = MemoryMapLimitsNew.fromBuffer(buffer, currentOffset);
    currentOffset += MemoryMapLimitsNew.LENGTH;
    currentOffset = 6416;
    memoryMap.limitsOld = MemoryMapLimitsOld.fromBuffer(buffer, currentOffset);
    currentOffset += MemoryMapLimitsOld.LENGTH;
    return memoryMap;
  }
}
