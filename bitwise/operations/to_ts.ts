/* eslint-disable no-console */
/* eslint-disable @typescript-eslint/no-unused-vars */
import ts, { Node, NodeFlags, SyntaxKind, factory } from "typescript";
import { BitwiseActionDict } from "../bitwise.ohm-bundle";
import { Field, FieldMask, Struct, TypeToken } from "../ast_types";
import { optionalExp } from "./to_ast";
import {
  CodeEmmit,
  advanceOffsetStatement,
  createCurrentOffsetVariableStatement,
  fieldArrayDecode,
  fieldMaskSingleDecode,
  fieldOffsetDirective,
  fieldSingleDecode,
  injectDataView,
  structExpArrayDecode,
  structExpSingleDecode,
} from "../ts_generators";

const TYPE_CONVERSION: Record<TypeToken, ts.KeywordTypeNode> = {
  bit: factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword),
  u8: factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),
  i8: factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),
  u16: factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),
  i16: factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),
  ul16: factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),
  il16: factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),
  u24: factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),
  i24: factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),
  ul24: factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),
  il24: factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),
  u32: factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),
  i32: factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),
  ul32: factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),
  il32: factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),
  bbcd: factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),
  lbcd: factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),
  char: factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),
};

export function print(node: Node, fileName: string): string {
  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });

  const sourceFile = ts.createSourceFile(
    fileName,
    "",
    ts.ScriptTarget.Latest,
    false, // setParentNodes
    ts.ScriptKind.TS,
  );

  // console.log(util.inspect(node, false, null, true));
  return printer.printNode(ts.EmitHint.Unspecified, node, sourceFile);
}

export function createFromCodeEmmit(codeEmmit: CodeEmmit): string {
  const statements = [
    ...codeEmmit.imports.filter((statement) => statement != null),
    ...codeEmmit.classes.filter((statement) => statement != null),
  ];

  const sourceFile = factory.createSourceFile(
    statements,
    factory.createToken(SyntaxKind.EndOfFileToken),
    NodeFlags.None,
  );

  ts.addSyntheticLeadingComment(
    statements[0],
    ts.SyntaxKind.MultiLineCommentTrivia,
    "This file is AUTO-GENERATED by the bitwise to TS compiler so scram!",
    true,
  );

  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed, removeComments: false });

  return printer.printFile(sourceFile);
}

const snakeToCamel = (str: string) =>
  str.toLowerCase().replace(/([-_][a-z])/g, (group) => group.toUpperCase().replace("-", "").replace("_", ""));

const capitalize = (str: string): string => str.charAt(0).toUpperCase() + str.slice(1);

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const toTS: BitwiseActionDict<any> = {
  Script(exps) {
    const codeEmmit = new CodeEmmit();

    const childrenCodeEmmits: CodeEmmit[] = exps.children.map((c) => c.toTS("<internal>"));

    // import BitView
    codeEmmit.imports = [
      factory.createImportDeclaration(
        undefined,
        factory.createImportClause(false, factory.createIdentifier("BitView"), undefined),
        factory.createStringLiteral("../bitview"),
        undefined,
      ),
      ...childrenCodeEmmits.flatMap((ce) => ce.imports),
    ];

    const className = `${this.args.name}MemoryMap`;
    console.log(`rule Script => className=${className}`);

    codeEmmit.classes = [
      ...childrenCodeEmmits.flatMap((ce) => ce.classes),
      factory.createClassDeclaration(
        [factory.createToken(ts.SyntaxKind.ExportKeyword)],
        factory.createIdentifier(className),
        undefined,
        undefined,
        [
          // class body
          // fields - propertydeclarations
          ...childrenCodeEmmits.flatMap((ce) => ce.fields),
          // fromBuffer
          factory.createMethodDeclaration(
            [factory.createToken(ts.SyntaxKind.PublicKeyword), factory.createToken(ts.SyntaxKind.StaticKeyword)],
            undefined,
            factory.createIdentifier("fromBuffer"),
            undefined,
            undefined,
            [
              factory.createParameterDeclaration(
                undefined,
                undefined,
                factory.createIdentifier("buffer"),
                undefined,
                factory.createTypeReferenceNode(factory.createIdentifier("Uint8Array"), undefined),
                undefined,
              ),
            ],
            factory.createTypeReferenceNode(factory.createIdentifier(className), undefined),
            factory.createBlock(
              [
                injectDataView(),
                factory.createVariableStatement(
                  undefined,
                  factory.createVariableDeclarationList(
                    [
                      factory.createVariableDeclaration(
                        factory.createIdentifier("memoryMap"),
                        undefined,
                        undefined,
                        factory.createNewExpression(factory.createIdentifier(className), undefined, []),
                      ),
                    ],
                    ts.NodeFlags.Const,
                  ),
                ),
                // let currentOffset = 0;
                createCurrentOffsetVariableStatement(factory.createNumericLiteral(0)),
                // decodeStatements
                ...childrenCodeEmmits
                  .flatMap((ce) => ce.decodeStatements)
                  .flatMap((generator) => generator("memoryMap")),
                // return
                factory.createReturnStatement(factory.createIdentifier("memoryMap")),
              ],
              true,
            ),
          ),
        ],
      ),
    ];

    // cant emmit fields
    // cant emmit decodeStatements
    // cant emmit encodeStatements

    return codeEmmit;
  },
  /*
    StructExp = DirectiveExp? "struct" "{" Exp+ "}" fieldName ("[" length "]")? ";"
  */
  StructExp(directiveExp, _arg1, _arg2, exps, _arg4, fieldnameExp, _arg6, lengthExp, _arg8, _arg9) {
    const ast: Struct = this.toAST();
    const codeEmmit = new CodeEmmit();

    const childrenCodeEmmits: CodeEmmit[] = exps.children.map((c) => c.toTS("<internal>"));

    codeEmmit.imports = childrenCodeEmmits.flatMap((ce) => ce.imports);

    const fieldName = snakeToCamel(fieldnameExp.toTS(""));
    const className = `MemoryMap${capitalize(fieldName)}`;
    const length = optionalExp(lengthExp)?.toTS("");
    const isArrayOfStruct = lengthExp.numChildren > 0;

    console.log(`rule StructExp => fielName=${fieldName} className=${className}`);

    codeEmmit.classes = [
      ...childrenCodeEmmits.flatMap((ce) => ce.classes).filter((e) => e != null),
      factory.createClassDeclaration(
        [factory.createToken(ts.SyntaxKind.ExportKeyword)],
        factory.createIdentifier(className),
        undefined,
        undefined,
        [
          ast.offset != null
            ? factory.createPropertyDeclaration(
                [factory.createToken(ts.SyntaxKind.PublicKeyword), factory.createToken(ts.SyntaxKind.StaticKeyword)],
                factory.createIdentifier("BASE"),
                undefined,
                factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),
                factory.createNumericLiteral(ast.offset.base),
              )
            : undefined,
          factory.createPropertyDeclaration(
            [factory.createToken(ts.SyntaxKind.PublicKeyword), factory.createToken(ts.SyntaxKind.StaticKeyword)],
            factory.createIdentifier("LENGTH"),
            undefined,
            factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),
            factory.createNumericLiteral(ast.byteLength),
          ),
          // fields
          ...childrenCodeEmmits.flatMap((ce) => ce.fields),
          // decodeMethod
          factory.createMethodDeclaration(
            [factory.createToken(ts.SyntaxKind.PublicKeyword), factory.createToken(ts.SyntaxKind.StaticKeyword)],
            undefined,
            factory.createIdentifier("fromBuffer"),
            undefined,
            undefined,
            [
              factory.createParameterDeclaration(
                undefined,
                undefined,
                factory.createIdentifier("buffer"),
                undefined,
                factory.createTypeReferenceNode(factory.createIdentifier("Uint8Array"), undefined),
                undefined,
              ),
              factory.createParameterDeclaration(
                undefined,
                undefined,
                factory.createIdentifier("offset"),
                undefined,
                factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),
                undefined,
              ),
            ],
            factory.createTypeReferenceNode(factory.createIdentifier(className), undefined),
            factory.createBlock(
              [
                injectDataView(),
                /*
                  const fieldName = new Classname();
                */
                factory.createVariableStatement(
                  undefined,
                  factory.createVariableDeclarationList(
                    [
                      factory.createVariableDeclaration(
                        factory.createIdentifier(fieldName),
                        undefined,
                        undefined,
                        factory.createNewExpression(factory.createIdentifier(className), undefined, []),
                      ),
                    ],
                    ts.NodeFlags.Const,
                  ),
                ),
                /*
                  ast.offset => let currentOffset = offset ?? MemoryMapPerbandpowersettings.BASE;
                  !ast.offset => let currentOffset = offset;
                */
                createCurrentOffsetVariableStatement(
                  ast.offset != null
                    ? factory.createBinaryExpression(
                        factory.createIdentifier("offset"),
                        factory.createToken(ts.SyntaxKind.QuestionQuestionToken),
                        factory.createPropertyAccessExpression(
                          factory.createIdentifier(className),
                          factory.createIdentifier("BASE"),
                        ),
                      )
                    : factory.createIdentifier("offset"),
                ),
                // decodeStatements
                ...childrenCodeEmmits.flatMap((ce) => ce.decodeStatements).flatMap((generator) => generator(fieldName)),
                // return statements
                factory.createReturnStatement(factory.createIdentifier(fieldName)),
              ],
              true,
            ),
          ),
        ].filter((e) => e != null),
      ),
    ];

    codeEmmit.fields = [
      factory.createPropertyDeclaration(
        [factory.createToken(ts.SyntaxKind.PublicKeyword)],
        factory.createIdentifier(fieldName),
        undefined,
        isArrayOfStruct
          ? factory.createArrayTypeNode(factory.createTypeReferenceNode(factory.createIdentifier(className), undefined))
          : factory.createTypeReferenceNode(factory.createIdentifier(className), undefined),
        undefined,
      ),
    ];

    // decodeStatements
    console.log(`rule StructExp => ${fieldName} is array ${isArrayOfStruct}`);
    codeEmmit.decodeStatements = [
      isArrayOfStruct
        ? structExpArrayDecode(className, fieldName, length)
        : structExpSingleDecode(className, fieldName, ast.byteLength, ast.offset),
    ];

    return codeEmmit;
  },
  /*
    FieldExp = DirectiveExp? typeToken FieldDefinitionExp ("[" length "]")? ";"
  */
  FieldExp(directive, typeToken, fieldDefinition, _arg3, length, _arg5, _arg6) {
    const codeEmmit = new CodeEmmit();

    const ast: Field | FieldMask = this.toAST();

    const typeNode: ts.KeywordTypeNode = typeToken.toTS("");
    const isFieldArray = ast.length > 1;

    if (ast instanceof FieldMask) {
      const fieldMask: FieldMask = ast;

      for (let i = 0; i < fieldMask.masks.length; i += 1) {
        const mask = fieldMask.masks[i];
        const maskName = snakeToCamel(mask.name);
        codeEmmit.fields.push(
          factory.createPropertyDeclaration(
            [factory.createToken(ts.SyntaxKind.PublicKeyword)],
            factory.createIdentifier(maskName),
            undefined,
            mask.bitLength > 1
              ? factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword)
              : factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword),
            undefined,
          ),
        );

        codeEmmit.decodeStatements.push(fieldMaskSingleDecode(maskName, mask.bitLength, mask.bitOffset));

        console.log(`rule FieldExp (maskfield) => fieldName=${maskName}`);
      }

      codeEmmit.decodeStatements.push(advanceOffsetStatement(1));
    } else {
      const fieldName = snakeToCamel(ast.name);
      codeEmmit.fields = [
        factory.createPropertyDeclaration(
          [factory.createToken(ts.SyntaxKind.PublicKeyword)],
          factory.createIdentifier(fieldName),
          undefined,
          isFieldArray ? factory.createArrayTypeNode(typeNode) : typeNode,
          undefined,
        ),
      ];

      codeEmmit.decodeStatements = [
        ast.offset != null ? fieldOffsetDirective(ast.offset) : null,
        ast.length > 1 ? fieldArrayDecode(fieldName, ast.type, ast.length) : fieldSingleDecode(fieldName, ast.type),
        advanceOffsetStatement(ast.byteLength),
      ].filter((e) => e != null);

      console.log(`rule FieldExp (field) => fieldName=${fieldName} length=${ast.length}`);
    }

    return codeEmmit;
  },
  /*
    singleLineComment = 
      | "//" singleLineCommentChars?
  */
  singleLineComment(_arg0, chars) {
    return new CodeEmmit();
  },
  typeToken(typeNode) {
    const typeValue = typeNode.sourceString;
    return TYPE_CONVERSION[typeValue];
  },
  length(_arg0): number {
    return parseInt(this.sourceString, 10);
  },
  fieldName(_arg0, _arg1) {
    return this.sourceString;
  },
  // eslint-disable-next-line no-underscore-dangle, @typescript-eslint/no-explicit-any
  _iter(...children): any {
    return children.map((n) => n.toTS(""));
  },
};

export default toTS;
